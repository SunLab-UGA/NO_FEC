# this script connects to a ZMQ server and sends a message and then quits (for now)

import zmq
import pmt
import numpy as np
import time
from datetime import datetime
from itertools import product

zmq_ports = [50000,50001,50002,50003] # list all the ports a connnection should be read
zmq_names = ['SNR', 'freq_offset', 'noise', 'encoding']
# zmq_rx_type = [np.float32] # list the data types for each port this is a message

TIME_PER_TEST = 5 # seconds
RATE = 1 # rate of tx in GNU Radio (interval)
print(f'samples per test: {TIME_PER_TEST/RATE}')

verbose_connection = False
contexts = []
sockets = []
for p in zmq_ports:
    contexts.append(zmq.Context())
    sockets.append(contexts[-1].socket(zmq.PUSH))
    rc = sockets[-1].bind(f"tcp://127.0.0.1:{p}") # connect, not bind, the PUB will bind, only 1 can bind
    #sockets[-1].setsockopt(zmq.SUBSCRIBE, b'') # subscribe to topic of all (needed or else it won't work)
    last_endpoint = sockets[-1].getsockopt(zmq.LAST_ENDPOINT)
    if verbose_connection:
        print(f"connection status: {rc}")
        print(f"last endpoint: {last_endpoint}")

print("ZMQ Connections Launched")

def send_value(socket, value): # gnuradio doesn't care about the key, just the value
    # create pmt message and send it
    key = pmt.to_pmt('xxxx')
    value = pmt.to_pmt(value)
    msg = pmt.cons(key, value)
    msg = pmt.serialize_str(msg)
    socket.send(msg)
    return

print("====== Starting Test ======")

# create a list of values to send
snr_values = np.arange(30, -15, -1.0) 
# freq_offset_values = np.linspace(-2e-6, 2e-6, len(snr_values)) # length of snr_values
freq_offset_values = np.linspace(0, 2e-6, 20)
noise_values = np.linspace(0, 1, 10)
encoding_values = np.arange(0, 9, 1) # 0-8, not inclusive

# 

show_values = False
if show_values:
    print(f"snr_values: {snr_values}")
    print(f'snr_values shape: {snr_values.shape}')
    print(f"freq_offset_values: {freq_offset_values}")
    print(f'freq_offset_values shape: {freq_offset_values.shape}')
    print(f"noise_values: {noise_values}")
    print(f'noise_values shape: {noise_values.shape}')
    print(f"encoding_values: {encoding_values}")
    print(f'encoding_values shape: {encoding_values.shape}')

iter_len = len(snr_values)*len(freq_offset_values)*len(noise_values)
for i,(s,f,n) in enumerate(product(snr_values, freq_offset_values, noise_values)): # iterate through all values
    print(f'snr:{s:.2f}, freq_offset:{f:.2f}, noise:{n:.2f} ({i}of{iter_len})', end='')
    print("", end='\r') # set to clear the line
    send_value(sockets[0], s) # send snr
    send_value(sockets[1], f) # send freq_offset
    send_value(sockets[2], n) # send noise
    # TODO count the number of messages received, and then send the next values
    time.sleep(TIME_PER_TEST)
    
print("====== Test Complete ======")